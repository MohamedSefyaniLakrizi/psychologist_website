// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or sqlite, mysql, etc.
  url      = env("DATABASE_URL")
}

model Client {
  id                   String      @id @default(cuid())
  firstName            String
  lastName             String
  phoneNumber          String
  email                String      @unique
  preferredContact     ContactMethod
  sendInvoiceAutomatically Boolean @default(true)
  defaultRate          Int         @default(300)
  confirmed            Boolean     @default(false) // For approval system
  deleted              Boolean     @default(false) // Soft delete flag - if true, client has data (appointments/invoices) and is archived
  appointments         Appointment[]
  notes                Note[]
  documents            Document[]
  invoices             Invoice[]
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  @@index([deleted])
}

model Appointment {
  id             String     @id @default(cuid())
  clientId       String
  client         Client     @relation(fields: [clientId], references: [id])
  startTime      DateTime
  endTime        DateTime
  format         AppointmentFormat
  status         AppointmentStatus? @default(NOT_YET_ATTENDED)
  isCompleted    Boolean    @default(false)
  isRecurring    Boolean    @default(false)
  recurringType  RecurringType?
  recurringEndDate DateTime?
  recurrentId    String?    
  confirmed      Boolean    @default(false) // For approval system
  // Jitsi meeting fields (only for online appointments)
  hostJwt        String?    // JWT token for the host
  clientJwt      String?    // JWT token for the client
  hostAttended   Boolean?   // Whether the host attended the meeting
  clientAttended Boolean?   // Whether the client attended the meeting
  notes          Note[]     
  emailSchedules EmailSchedule[]
  invoice        Invoice?   // One-to-one relationship with invoice
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
}

model EmailSchedule {
  id          String   @id @default(cuid())
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  
  emailType   EmailType
  scheduledFor DateTime
  status      EmailStatus @default(PENDING)
  
  // Email content
  recipientEmail String
  recipientName  String
  subject       String
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  sentAt      DateTime?
  errorMessage String?
  
  @@index([scheduledFor])
  @@index([status])
  @@index([appointmentId])
}

model Note {
  id             String     @id @default(cuid())
  clientId       String?    // optional link to a client
  appointmentId  String?    // optional link to a session
  client         Client?    @relation(fields: [clientId], references: [id])
  appointment    Appointment? @relation(fields: [appointmentId], references: [id])
  title          String
  content        Json       // Lexical content
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
}

model Document {
  id         String   @id @default(cuid())
  clientId   String
  client     Client   @relation(fields: [clientId], references: [id])
  fileName   String
  fileUrl    String   // URL to the uploaded PDF (e.g., S3 or local)
  uploadedAt DateTime @default(now())
}

model Invoice {
  id            String        @id @default(cuid())
  clientId      String
  client        Client        @relation(fields: [clientId], references: [id])
  appointmentId String?       @unique // Optional, one-to-one with appointment
  appointment   Appointment?  @relation(fields: [appointmentId], references: [id])
  amount        Decimal       @db.Decimal(10, 2)
  status        InvoiceStatus @default(UNPAID)
  paymentMethod PaymentMethod?
  description   String?       // Optional description
  dueDate       DateTime?     // Optional due date
  paidAt        DateTime?     // When it was paid
  emailSent     Boolean       @default(false) // Whether invoice has been sent by email
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([clientId])
  @@index([appointmentId])
  @@index([dueDate])
}

enum ContactMethod {
  PHONE
  EMAIL
  SMS
  WHATSAPP
}

enum AppointmentFormat {
  ONLINE
  FACE_TO_FACE
}

enum AppointmentStatus {
  NOT_YET_ATTENDED  // Future appointments
  ATTENDED          // Completed and attended
  ABSENT           // Completed but client didn't show up
  CANCELLED        // Cancelled appointment
}

enum RecurringType {
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum EmailType {
  CONFIRMATION
  REMINDER_24H
  REMINDER_1H
  INVOICE_DELIVERY
}

enum EmailStatus {
  PENDING
  SENT
  CANCELLED
  FAILED
}

enum InvoiceStatus {
  UNPAID
  PAID
  OVERDUE
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  CHECK
  OTHER
}

// Weekly recurring availability template
model WeeklyAvailability {
  id         String   @id @default(cuid())
  weekday    Int      // 0=Monday, 1=Tuesday, ..., 6=Sunday
  startTime  String   // "09:00" (HH:mm format)
  endTime    String   // "17:00" (HH:mm format)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([weekday, startTime, endTime])
  @@index([weekday])
}

// Specific date overrides (overrides weekly template for specific dates)
model DateAvailability {
  id        String   @id @default(cuid())
  date      DateTime // Specific date (time set to 00:00:00)
  startTime String?  // "09:00" - null means closed all day
  endTime   String?  // "17:00" - null means closed all day
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date, startTime, endTime])
  @@index([date])
}
